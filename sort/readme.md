# sort

## Selection Sort 
- 현재 위치에 들어갈 값을 찾아 정렬하는 배열.

#### 로직

1. 정렬 되지 않은 인덱스의 맨 앞에섭부터, 이를 포함한 그 이후의 배열값 중 가장 작은 값을 찾아간다.

2. 가장 작은 값을 찾으면, 그 값을 현재 인덱스의 값과 바꿔준다.

3. 다음 인덱스에서 위 과정을 반복해준다.

## Insertion Sort 
- 현재 위치에서, 그 이하의 배열들을 비교하여 자신이 들어갈 위치를 찾아, 그 위치에 삽입하는 배열 알고리즘이다.

#### 로직

1. 삽입 정렬은 두 번째 인덱스부터 시작한다. 현재 인덱스는 별도의 변수에 저장해주고, 비교 인덱스를 현재 인덱스 -1로 잡는다.

2. 별도로 저장해 둔 삽입을 위한 변수와, 비교 인덱스의 배열 값을 비교한다.

3. 만약 삽입 변수가 더 크면, 비교 인덱스 +1에 삽입 변수를 저장한다.

## Bubble Sort
- 매번 연속된 두개 인덱스를 비교하여, 정한 기준의 값을 뒤로 넘겨 정렬한다.

#### 로직

1. 삽입 정렬은 두 번째 인덱스부터 시작. 현재 인덱스의 값과 바로 이전의 인덱스의 값을 비교.

2. 만약 이전 인덱스가 더 크면, 현재 인덱스와 바꿔준다.

3. 현재 인덱스가 더 크면, 교환하지 않고 다음 두 연속된 배열값을 비교한다.

4. 이걸 (전체 배열의 크기 - 현재까지 순환한 수)만큼 반복한다.

## Merge Sort
- 분할 정복 방식으로 설계된 알고리즘이다. 반으로 쪼개 문제를 해결해 나가는 방식. 배열의 크기가 1보다 작거나 같을 때 까지 반복된다.

#### 로직

분할과정

1. 현재 배열을 반으로 쪼갠다. 배열의 시작 위치와, 종료 위치를 입력받아 둘을 더한 후 2를 나눠 그 위치를 기준으로 나눈다.

2. 이를 쪼갠 배열의 크기가 0이거나 1일때까지 반복한다.

합병과정

1. 두 배열 A, B의 크기를 비교한다. 각각의 배열의 현재 인덱스를 i, j로 가정

2. i 에는 A 배열의 시작 인덱스를 저장하고, j에는 B 배열의 시작 주소를 저장한다.

3. A[i]와  B[i]를 비교한다. 오름차순의 경우 이중에 작은 값을 새 배열 C에 저장한다. A[i]가 더 컸다면 A[i]의 값을 배열 C에 저장해주고, i의 값을 하나 증가시켜준다.

4. 이를 i나 j 둘중 하나가 각자 배열의 끝에 도달할 때까지 반복한다.

5. 끝까지 저장을 못한 배열의 값을, 순서대로 전부 다 C에 저장한다.

6. C 배열을 원래의 배열에 저장해준다.

## Quick Sort
- 분할 정복을 이용하여 정렬을 수행하는 알고리즘 pivot point라고 기준이 되는 값을 하나 설정하여, 이 값을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 옮기는 방식으로 정렬을 진행한다.

#### 로직

1. pivot point로 잡을 배열의 값 하나를 정한다. 보통 맨 앞이나 맨 뒤, 혹은 전체 배열 값 중 중간값이나 랜덤값으로 정한다.

2. 분할을 진행하기에 앞서, 비교를 진행하기 위해 가장 왼쪽 배열의 인덱스를 저장하는 left변수, 가장 오른쪽 배열의 인덱스를 저장한 right변수를 생성한다.

3. right부터 비교를 진행한다. 비교는 right가 left보다 클 때만 반복. 비교한 배열값이 pivot point보다 크면 right를 하나 감소하고 비교 반복. 만약 pivot point보다 작은 배열 값을 찾으면 반복을 중지한다.

4. 다음 left부터 비교를 진행한다. right가 left보다 클 때만 반복하며, 비교한 배열 값이 pivot point보다 작으면 left를 하나 증가시키고 비교를 반복한다. 만약 pivot point 보다 큰 배열 값을 찾으면 반복을 중지한다.

5. left 인덱스의 값과 right 인덱스의 값을 스왑한다.

6. 3, 4, 5의 과정을 left < right가 만족 할 때 까지 반복한다.

7. 위의 과정들이 끝나면 left의 값과 pivot point를 바꿔준다.

8. 맨 왼쪽부터 left - 1까지, left + 1부터 맨 오른쪽까지로 나눠 퀵정렬을 반복한다.
